# 8.2 Generator

## Learning Objectives

By the end of this lesson, you should be able to:

- Understand what generators are in Python.
- Use generator expressions to create generators.
- Use the `yield` statement to define generator functions.

## Introduction

In Python, a generator is a special type of iterator that generates values on the fly. Generators are used to create iterators in an easy and efficient way. They allow you to iterate over a sequence of values without having to store them in memory.

Generators are defined using generator expressions or generator functions, while iterators are defined using classes and the `__iter__()` and `__next__()` methods.

We briefly learnt about it in [4.4: Comprehensions](../4-conditionals-and-iterations/4.4-comprehensions.md) where we discussed generator comprehensions. In this lesson, we will explore generators in more detail.

## Generator Expressions

Generator expressions are a concise way to create generators in Python. They have a similar syntax to list comprehensions but use parentheses `()` instead of square brackets `[]`. Generator expressions are more memory-efficient than list comprehensions because they generate values on the fly instead of storing them in memory.

For example, you can create a generator that generates the squares of numbers from 1 to 5 as follows:

```python
squares = (x ** 2 for x in range(1, 6))

print(squares)  # <generator object <genexpr> at 0x7f8b1c7b3d60>
```

In this example, the generator expression `(x ** 2 for x in range(1, 6))` generates the squares of numbers from 1 to 5. The generator object `squares` can be used to iterate over the generated values.

Now, you can iterate over the generator object and print the squares of the numbers:

```python
for square in squares:
    print(square)
```

## Generator Functions

Generator functions are functions that use the `yield` statement to return values one at a time. When a generator function is called, it returns a generator object that can be used to iterate over the values generated by the function.

To define a generator function, you use the `yield` statement instead of `return`. The `yield` statement pauses the function and saves its state so that it can resume execution from the same point later.

For example, you can define a generator function that generates the Fibonacci sequence as follows:

```python
def fibonacci(limit):
    a, b = 0, 1
    count = 0

    while count < limit:
        yield a
        a, b = b, a + b
        count += 1

fibonacci_sequence = fibonacci(5)

for number in fibonacci_sequence:
    print(number)
```

The `fibonacci()` function is a generator function that generates the Fibonacci sequence up to a given limit. The `yield` statement is used to return the next element in the sequence. The generator object `fibonacci_sequence` can be used to iterate over the generated values.

## Exercise

1. Write a generator function that generates the squares of numbers from `1` to `n`.
2. Use the generator function to generate the squares of numbers from `1` to `5` and print the squares.
3. Write a generator function that generates the first `n` even numbers starting from `0`.
4. Use the generator function to generate the first `10` even numbers starting from `0` and print the numbers.
